<!DOCTYPE html>


  <html class="dark page-post">


<head>
  <meta charset="utf-8">
  
  <title>知识点汇总一 | 感叹号！</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="前端,设计,Hexo主题,前端开发,用户体验,设计,frontend,design,nodejs,JavaScript,React,iOS" />
  

  <meta name="description" content="三栏布局 高度固定，左右宽度300px,中间自适应   1. 浮动  2. 绝对定位  3. flex布局  4. table布局  5. grid布局  CSS盒模型 css盒子模型 又称框模型 (Box Model) ，包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素  标准模型+IE模型 css如何设置两种模型 box-sizi">
<meta property="og:type" content="article">
<meta property="og:title" content="知识点汇总一">
<meta property="og:url" content="http://www.vizong.cn/5/index.html">
<meta property="og:site_name" content="感叹号！">
<meta property="og:description" content="三栏布局 高度固定，左右宽度300px,中间自适应   1. 浮动  2. 绝对定位  3. flex布局  4. table布局  5. grid布局  CSS盒模型 css盒子模型 又称框模型 (Box Model) ，包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素  标准模型+IE模型 css如何设置两种模型 box-sizi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.smyhvae.com/2015-10-03-css-27.jpg">
<meta property="og:image" content="http://img.smyhvae.com/2015-10-03-css-30.jpg">
<meta property="article:published_time" content="2022-01-19T03:08:28.000Z">
<meta property="article:modified_time" content="2022-01-21T06:04:06.332Z">
<meta property="article:author" content="Metoo">
<meta property="article:tag" content="前端,设计,Hexo主题,前端开发,用户体验,设计,frontend,design,nodejs,JavaScript,React,iOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.smyhvae.com/2015-10-03-css-27.jpg">

  

  
    <link rel="icon" href="/images/favicon.png">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    
<link rel="stylesheet" href="/css/personal-style.css">

  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?781972f98f874b46f6e07630bf89e654";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
  <!-- <script src="https://cdn.jsdelivr.net/gh/vivizong/vivizong.github.io/js/changeTitle.js"></script> -->

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="感叹号！" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css"></head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">导航</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">导航</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80"><span class="toc-text">三栏布局</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSS%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-text">CSS盒模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%A8%A1%E5%9E%8B-IE%E6%A8%A1%E5%9E%8B"><span class="toc-text">标准模型+IE模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%9E%8B"><span class="toc-text">css如何设置两种模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFC"><span class="toc-text">BFC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC%E7%9A%84%E5%B8%83%E5%B1%80%E8%A7%84%E5%88%99-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">BFC的布局规则&#x2F;基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BABFC"><span class="toc-text">如何创建BFC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-text">实际应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6"><span class="toc-text">DOM事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BA%A7%E5%88%AB"><span class="toc-text">DOM事件的级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-text">DOM事件模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-text">DOM事件流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-text">DOM事件捕获的具体流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Event%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8"><span class="toc-text">Event对象的常见应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6-%E6%A8%A1%E6%8B%9F%E4%BA%8B%E4%BB%B6"><span class="toc-text">自定义事件&#x2F;模拟事件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE%E7%B1%BB"><span class="toc-text">HTTP协议类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-text">HTTP协议的主要特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-text">HTTP报文的组成部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E6%96%B9%E6%B3%95"><span class="toc-text">HTTP方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E5%90%97"><span class="toc-text">HTTP状态吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5"><span class="toc-text">持久连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%BA%BF%E5%8C%96"><span class="toc-text">管线化</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-知识点汇总一/知识点汇总一" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">知识点汇总一</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2022.01.19</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Metoo</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/">面试</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h1><p>高度固定，左右宽度300px,中间自适应</p>
<ol>
<li>浮动</li>
<li>绝对定位</li>
<li>flex布局</li>
<li>table布局</li>
<li>grid布局</li>
</ol>
<h1 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h1><p>css盒子模型 又称框模型 (Box Model) ，包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素</p>
<h2 id="标准模型-IE模型"><a href="#标准模型-IE模型" class="headerlink" title="标准模型+IE模型"></a>标准模型+IE模型</h2><img src="http://img.smyhvae.com/2015-10-03-css-27.jpg" alt="标准模" style="zoom:45%;" />

<img src="http://img.smyhvae.com/2015-10-03-css-30.jpg" alt="IE模" style="zoom:45%;" />

<h2 id="css如何设置两种模型"><a href="#css如何设置两种模型" class="headerlink" title="css如何设置两种模型"></a>css如何设置两种模型</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">box-sizing</span><span class="token punctuation">:</span>content-box<span class="token punctuation">;</span> // 标准盒模型
<span class="token property">box-sizing</span><span class="token punctuation">:</span>border-box<span class="token punctuation">;</span> // IE盒模型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>BFC(Block formatting context)直译为”块级格式化上下文”</p>
<h3 id="BFC的布局规则-基本原理"><a href="#BFC的布局规则-基本原理" class="headerlink" title="BFC的布局规则/基本原理"></a>BFC的布局规则/基本原理</h3><ul>
<li><p>内部的Box会在垂直方向，一个接一个地放置。</p>
</li>
<li><p>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。</p>
</li>
<li><p>每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的*格式化，否则相反)。即使存在浮动也是如此。</p>
</li>
<li><p>BFC的区域不会与float box重叠。</p>
</li>
<li><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p>
</li>
<li><p>计算BFC的高度时，浮动元素也参与计算</p>
</li>
</ul>
<h3 id="如何创建BFC"><a href="#如何创建BFC" class="headerlink" title="如何创建BFC"></a>如何创建BFC</h3><ol>
<li><p>overflow不为visible;</p>
</li>
<li><p>float的值不为none；</p>
</li>
<li><p>position的值不为static或relative；</p>
</li>
<li><p>display属性为inline-blocks,table,table-cell,table-caption,flex,inline-flex;</p>
</li>
</ol>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><ul>
<li><p>解决相邻元素margin重叠的问题</p>
</li>
<li><p>布局中的浮动</p>
</li>
</ul>
<h1 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h1><p>基本概念：DOM事件的级别</p>
<p>DOM事件模型：冒泡和捕获</p>
<h2 id="DOM事件的级别"><a href="#DOM事件的级别" class="headerlink" title="DOM事件的级别"></a>DOM事件的级别</h2><pre class="line-numbers language-none"><code class="language-none">DOM0 	element.onclick&#x3D;function()&#123;&#125;

DOM2	element.addEventListener(&#39;click&#39;,function()&#123;&#125;,false)

DOM3	element.addEventListener(&#39;keyup&#39;,function()&#123;&#125;,false)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="DOM事件模型"><a href="#DOM事件模型" class="headerlink" title="DOM事件模型"></a>DOM事件模型</h2><p>捕获和冒泡</p>
<p>捕获是从上到下，冒泡是当前事件往上</p>
<h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>就是浏览器在为这个当前页面与用户做交互的过程中。用户点击了鼠标左键，这个左键是怎么传递的，它又怎么响应的。</p>
<p>第一阶段：捕获。事件通过捕获到达目标元素（目标元素既目标阶段）。</p>
<p>第二阶段：目标阶段。 比如说用户当前点击了这个按钮，这个按钮就是目标阶段</p>
<p>第三阶段：冒泡 。 目标阶段通过冒泡上传到window对象</p>
<h2 id="DOM事件捕获的具体流程"><a href="#DOM事件捕获的具体流程" class="headerlink" title="DOM事件捕获的具体流程"></a>DOM事件捕获的具体流程</h2><p>捕获是从上到下的这个过程，第一个接收事件的对象是window—&gt;document—&gt;html—&gt;body—&gt;….目标元素</p>
<p> 比如我想取到body标签。可以使用window.docment.body来取到</p>
<p> 但是html不能这样获取到，它是专门一个表示节点对象的document.documentElement </p>
<h2 id="Event对象的常见应用"><a href="#Event对象的常见应用" class="headerlink" title="Event对象的常见应用"></a>Event对象的常见应用</h2><p>Event对象是事件响应中一个很重要的对象。因为我们经常会去获取用户交互的一个参数</p>
<p>以下5个是常见却很容易弄混的。</p>
<ol>
<li><p>event.preventDefault();   阻止默认事件。</p>
<p>比如说，一个a标签，a标签绑定了一个事件。那么在响应函数中，如果设置了event.preventDefault() . 就阻止了a标签的一个默认的跳转行为。</p>
</li>
<li><p>event.stopPropagation();  阻止冒泡的一个行为。</p>
<p> 比如说，我父元素绑定一个事件，我子元素也绑定一个事件。这时我想子元素执行子元素的事件，父元素执行父元素的事件。</p>
<p>如果你阻止冒泡，当单机子元素的时候，按照冒泡的原理，父元素也会被响应。这个时候就应该添加一个阻止冒泡。</p>
</li>
<li><p>event.stopImmediatePropagation() ;</p>
<p> 比如说，一个按钮绑定了两个click事件。click1 和click2. 当我想通过优先的方式，当我想执行click1的时候不要执行click2了</p>
<p>那么怎么办呢？？这时候在click1 事件中加入这么一句，它就能成功的阻止click2 事件的执行。</p>
</li>
<li><p>event.currentTarget</p>
</li>
<li><p>event.target </p>
</li>
</ol>
<p>eg：事件委托。</p>
<p>比如说 给你一个for循环，给一个dom注册了事件，要怎么优化。</p>
<p>一个父元素有10个子元素，你又不想给10个子元素都绑定一个click元素。那么只要在父级元素上绑定一个事件就可以了。</p>
<p>这个时候就可以使用事件委托。将子元素的事件转移到父元素身上。然后在绑定事件。然后再响应的时候，区分是哪个元素被点击。那么是怎么区分是哪个子元素被点击的呢？</p>
<p>这个时候就是target上场的时候。</p>
<h2 id="自定义事件-模拟事件"><a href="#自定义事件-模拟事件" class="headerlink" title="自定义事件/模拟事件"></a>自定义事件/模拟事件</h2><p>new Event（） 和 CustomEvent() </p>
<p>两个的区别是 ：new Event（） 只能指定事件名，而CustomEvent 还能在后面加个参数。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> eat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Event</span><span class="token punctuation">(</span><span class="token string">"eat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ev<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"eat"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'eat'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
 
ev<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>eat<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li><p>new Event(“eat”)  ： 新建自定义事件并命名</p>
</li>
<li><p> 通过DOM2 这种事件的注册方式绑定事件名称：</p>
</li>
</ol>
<p>​      ev.addEventListener(“eat”,function(){<br>            console.log(‘eat’);<br>​      })</p>
<ol start="3">
<li>使用 ev.dispatchEvent(eat);  这个事件来触发eve这个对象。</li>
</ol>
<p>这样就达到了 自定义事件和响应自定义事件。</p>
<h1 id="HTTP协议类"><a href="#HTTP协议类" class="headerlink" title="HTTP协议类"></a>HTTP协议类</h1><h2 id="HTTP协议的主要特点"><a href="#HTTP协议的主要特点" class="headerlink" title="HTTP协议的主要特点"></a>HTTP协议的主要特点</h2><ul>
<li>简单快速</li>
<li>灵活</li>
<li>无连接</li>
<li>无状态</li>
</ul>
<h2 id="HTTP报文的组成部分"><a href="#HTTP报文的组成部分" class="headerlink" title="HTTP报文的组成部分"></a>HTTP报文的组成部分</h2><p>请求报文</p>
<ul>
<li>请求行</li>
<li>请求头</li>
<li>空行</li>
<li>请求体</li>
</ul>
<p>相应报文</p>
<ul>
<li>状态行</li>
<li>相应头</li>
<li>空行</li>
<li>响应体</li>
</ul>
<h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><ul>
<li>GET    获取资源</li>
<li>POST   传输资源</li>
<li>PUT    更新资源</li>
<li>DELETE   删除资源</li>
<li>HEAD    获得报文首部</li>
</ul>
<h2 id="HTTP状态吗"><a href="#HTTP状态吗" class="headerlink" title="HTTP状态吗"></a>HTTP状态吗</h2><ul>
<li>1xx 提供信息,表示已经接受，正在处理</li>
<li>100 continue主要用于提供信息</li>
<li>101 切换协议：如果服务器切换了协议会向客户端返回101</li>
<li>2xx 成功</li>
<li>200:ok</li>
<li>201：已创建</li>
<li>202：已接收</li>
<li>203：非权威内容</li>
<li>204：请求成功，但是无资源返回</li>
<li>205：重置内容</li>
<li>206：客户端进行了范围请求，服务器成功执行力这部分的请求，返回头部有Content-range指定了范围的实体内容</li>
<li>3xx重定向</li>
<li>300:用户请求了多个选项的资源</li>
<li>301：永久转移，资源已经被分配了新的URL，应该按照location部分的url重新保存</li>
<li>302：临时重定向</li>
<li>303：该资源存在着另一个URL，可以使用GET方法获取</li>
<li>304：没有修改（协商缓存命中时返回这个状态码）</li>
<li>305：使用代理</li>
<li>307：临时重定向</li>
<li>308：永久重定向</li>
<li>4xx客户端错误</li>
<li>400:报文存在语法错误</li>
<li>401：需要认证信息</li>
<li>403：被服务器拒绝</li>
<li>404：服务器上没有该资源</li>
<li>405：服务器禁止使用该方法</li>
<li>5xx服务端错误 </li>
</ul>
<h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><p>HTTP协议采用‘请求-应答’模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建一个连接，完成柱子后立即断开连接（HTTP协议为无连接的协议）</p>
<p>当使用 Keep-Alive 模式 （又称持久连接、连接重用）时，Keep-Alive功能是客户端到服务器短的连接持续有效，当出现对服务器的后续请求时，Keep-Alive功能避免了建立或者重新建立连接</p>
<h2 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h2><p>在使用持久连接的情况下，某个连接上的消息传递类似于</p>
<p>请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 -&gt; 响应3<br>管线化，某个连接上的消息变成了类似下面这样 （相当于将请求打包一次传输过去，服务端也打包响应回来）</p>
<p>请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3</p>
<ul>
<li>管线化机智通过持久连接完成，仅HTTP/1.1支持此技术</li>
<li>只有GET和HEAD请求可以进行管线化，而POST则有所限制</li>
<li>初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持HTTP/1.1版本的协议；</li>
<li>管线化不会用箱响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变</li>
<li>HTTP1.1要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可</li>
<li>现在很多服务器端和代理程序对管线化的支持并不好，现代浏览器Chrome和Firefox默认并未开启管线化支持</li>
</ul>
<p>本文链接： <a href="http://www.vizong.cn/5/">http://www.vizong.cn/5/</a> </p>

    
  </div>

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持Metoo</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/wx.jpg" alt="">
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/zfb.jpg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/4/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/6/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: '0a46e8f5cc23d5c9cceb',
  clientSecret: '58178a18d68b1b93b3fec0f35ed016baeb89a03d',
  repo: 'blog-comment',
  owner: 'vivizong',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: md5(location.pathname),
  admin: ['vivizong'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
      console.log('js加载成功')
    });
    loadScript('/js/changeTitle.js?2232', function() {
      // load success
      console.log('js加载成功')
    });
  }
</script>

</body>
</html>
