[{"title":"知识点汇总四-Node","url":"http://www.vizong.cn/1/","content":"<h1 id=\"nvm-n管理node版本\"><a href=\"#nvm-n管理node版本\" class=\"headerlink\" title=\"nvm/n管理node版本\"></a>nvm/n管理node版本</h1><h1 id=\"模块化的差异，AMD-COMMONJS-ESMODULE\"><a href=\"#模块化的差异，AMD-COMMONJS-ESMODULE\" class=\"headerlink\" title=\"模块化的差异，AMD,COMMONJS,ESMODULE\"></a><a href=\"https://www.imooc.com/article/20057\">模块化的差异，AMD,COMMONJS,ESMODULE</a></h1><p>AMD：依赖前置  动态引入</p>\n<p>commonjs: request引入 动态引入</p>\n<p>esmodule: 静态引入</p>\n<h1 id=\"Less-js-，sass-ruby-stylus-css-命名空间与css-module\"><a href=\"#Less-js-，sass-ruby-stylus-css-命名空间与css-module\" class=\"headerlink\" title=\"Less(js)，sass(ruby), stylus,css, 命名空间与css module\"></a>Less(js)，sass(ruby), stylus,css, 命名空间与css module</h1><p>本文链接： <a href=\"http://www.vizong.cn/1/\">http://www.vizong.cn/1/</a> </p>\n","categories":["121202"],"tags":[]},{"title":"知识点汇总三","url":"http://www.vizong.cn/7/","content":"<h1 id=\"this的指向\"><a href=\"#this的指向\" class=\"headerlink\" title=\"this的指向\"></a>this的指向</h1><p>this指代是 【当前对象】所谓的当前对象，是指此刻正在执行这个函数的对象</p>\n<p>哪个对象调用函数，函数里面的this指向哪个对象</p>\n<h1 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h1><blockquote>\n<p> <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">箭头函数表达式</a>的语法比<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function\">函数表达式</a>更简洁，并且没有自己的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this\">this</a>，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments\">arguments</a>，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super\">super</a>或<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target\">new.target</a>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p>\n</blockquote>\n<p>从mdn的文档中可以看到：</p>\n<ul>\n<li>没有单独的this</li>\n<li>不绑定arguments</li>\n<li>箭头函数不能用作构造器，和 new一起用会抛出错误</li>\n<li>箭头函数没有prototype属性</li>\n</ul>\n<p>箭头函数是有构造函数的，但特别的是，它作为一个函数，它是没有prototype属性的</p>\n<h1 id=\"eval函数是做什么的\"><a href=\"#eval函数是做什么的\" class=\"headerlink\" title=\"eval函数是做什么的\"></a>eval函数是做什么的</h1><h1 id=\"防抖函数\"><a href=\"#防抖函数\" class=\"headerlink\" title=\"防抖函数\"></a>防抖函数</h1><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token comment\">/**\n * @desc 函数防抖\n * @param func 函数\n * @param wait 延迟执行毫秒数\n * @param immediate true 表立即执行，false 表非立即执行\n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">debounce</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">func<span class=\"token punctuation\">,</span>wait<span class=\"token punctuation\">,</span>immediate</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">var</span> timeout<span class=\"token punctuation\">;</span>\n \n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">var</span> context <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">var</span> args <span class=\"token operator\">=</span> arguments<span class=\"token punctuation\">;</span>\n \n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>timeout<span class=\"token punctuation\">)</span> <span class=\"token function\">clearTimeout</span><span class=\"token punctuation\">(</span>timeout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>immediate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">var</span> callNow <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>timeout<span class=\"token punctuation\">;</span>\n            timeout <span class=\"token operator\">=</span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                timeout <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> wait<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>callNow<span class=\"token punctuation\">)</span> <span class=\"token function\">func</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n            timeout <span class=\"token operator\">=</span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token function\">func</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> wait<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// let context = this;</span>\n<span class=\"token comment\">// let args = arguments;</span>\n<span class=\"token comment\">// 防抖函数的代码使用这两行代码来获取 this 和 参数，是为了让 debounce 函数最终返回的函数 this 指向不变以及依旧能接受到 e 参数</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"节流函数\"><a href=\"#节流函数\" class=\"headerlink\" title=\"节流函数\"></a>节流函数</h1><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token comment\">/**\n * @desc 函数节流\n * @param func 函数\n * @param wait 延迟执行毫秒数\n * @param type 1 表时间戳版，2 表定时器版\n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">throttle</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">func<span class=\"token punctuation\">,</span> wait <span class=\"token punctuation\">,</span>type</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>type<span class=\"token operator\">===</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">var</span> previous <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>type<span class=\"token operator\">===</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">var</span> timeout<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n \n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">var</span> context <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">var</span> args <span class=\"token operator\">=</span> arguments<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>type<span class=\"token operator\">===</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">var</span> now <span class=\"token operator\">=</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n \n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>now <span class=\"token operator\">-</span> previous <span class=\"token operator\">></span> wait<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token function\">func</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                previous <span class=\"token operator\">=</span> now<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>type<span class=\"token operator\">===</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>timeout<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                timeout <span class=\"token operator\">=</span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                    timeout <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token function\">func</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> wait<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n \n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">// 其实时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h1><p>函数的多参变成单参</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> —<span class=\"token operator\">></span><span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">return</span> a<span class=\"token operator\">*</span>b<span class=\"token operator\">*</span>c<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">c</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">return</span> a<span class=\"token operator\">*</span>b<span class=\"token operator\">*</span>c<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"作用域链是什么\"><a href=\"#作用域链是什么\" class=\"headerlink\" title=\"作用域链是什么\"></a>作用域链是什么</h1><p>在JavaScript中，变量的作用域有全局作用域和局部作用域/函数作用域两种。ES6有了块级作用域</p>\n<p>一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。</p>\n<p>但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。</p>\n<h1 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h1><ol>\n<li><p>标记清除</p>\n</li>\n<li><p>引用计数</p>\n</li>\n</ol>\n<h1 id=\"Promise-async-await-Generator区别\"><a href=\"#Promise-async-await-Generator区别\" class=\"headerlink\" title=\"Promise/async await/Generator区别\"></a><a href=\"https://blog.csdn.net/qq_37430247/article/details/110143159\">Promise/async await/Generator</a>区别</h1><p>Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值</p>\n<p>Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态</p>\n<h1 id=\"Map-flatMap-reduce\"><a href=\"#Map-flatMap-reduce\" class=\"headerlink\" title=\"Map/flatMap/reduce\"></a>Map/flatMap/reduce</h1><p>通过map遍历返回的数据形成新数组与原数组之间没有引用关系</p>\n<h1 id=\"深拷贝和浅拷贝\"><a href=\"#深拷贝和浅拷贝\" class=\"headerlink\" title=\"深拷贝和浅拷贝\"></a><a href=\"https://www.jianshu.com/p/1c142ec2ca45\">深拷贝和浅拷贝</a></h1><p>本文链接： <a href=\"http://www.vizong.cn/7/\">http://www.vizong.cn/7/</a> </p>\n","categories":["前端"],"tags":[]},{"title":"知识点汇总二","url":"http://www.vizong.cn/6/","content":"<h1 id=\"创建对象的几种方法\"><a href=\"#创建对象的几种方法\" class=\"headerlink\" title=\"创建对象的几种方法\"></a>创建对象的几种方法</h1><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 第一种方式：字面量</span>\n<span class=\"token keyword\">var</span> o1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span><span class=\"token string\">'o1'</span><span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">var</span> o2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span><span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span><span class=\"token string\">'o2'</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 第二种方式：通过构造函数</span>\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">M</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span>name<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> o3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">M</span><span class=\"token punctuation\">(</span><span class=\"token string\">'o3'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 第三种方式：Object.create</span>\n<span class=\"token keyword\">var</span> p <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span><span class=\"token string\">'p'</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> o4 <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"原型、构造函数、实例、原型链\"><a href=\"#原型、构造函数、实例、原型链\" class=\"headerlink\" title=\"原型、构造函数、实例、原型链\"></a>原型、构造函数、实例、原型链</h1><p><img src=\"./WX20220118-151049@2x.png\"></p>\n<!-- <img src=\"/Users/weichengzong/My/文档目录/WX20220118-151049@2x.png\" style=\"zoom:50%;\" /> -->\n\n<p>完整图</p>\n<p><img src=\"https://camo.githubusercontent.com/9a69b0f03116884e80cf566f8542cf014a4dd043fce6ce030d615040461f4e5a/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065352e706e67\" alt=\"关系图\"></p>\n<h1 id=\"instanceof原理\"><a href=\"#instanceof原理\" class=\"headerlink\" title=\"instanceof原理\"></a>instanceof原理</h1><p><code>instanceof</code> 运算符用于测试构造函数的 <code>prototype</code> 属性是否出现在对象原型链中的任何位置</p>\n<p>如果<code>A instanceof B</code>，那么 <code>A</code> 必须是一个对象，而 <code>B</code> 必须是一个合法的 JavaScript 函数。在这两个条件都满足的情况下：</p>\n<p>判断 B 的 prototype 属性指向的原型对象(B.prototype)是否在对象 A 的原型链上。</p>\n<p>如果在，则为 true；如果不在，则为 false。</p>\n<p><img src=\"./WX20220118-152742@2x.png\"></p>\n<!-- <img src=\"/Users/weichengzong/My/文档目录/WX20220118-152742@2x.png\" style=\"zoom:50%;\" /> -->\n\n<h1 id=\"new运算符\"><a href=\"#new运算符\" class=\"headerlink\" title=\"new运算符\"></a>new运算符</h1><ol>\n<li>一个新对象被创建。它继承自foo.prototype</li>\n<li>构造函数foo被执行。执行的时候，相应的传参会被传入，同时上下文（this）会被指定为新的实例。new foo等同于new foo(),只能用在不传递任何参数的情况</li>\n<li>如果构造函数返回了一个对象，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象</li>\n</ol>\n<h1 id=\"面向对象类\"><a href=\"#面向对象类\" class=\"headerlink\" title=\"面向对象类\"></a>面向对象类</h1><h2 id=\"类的声明\"><a href=\"#类的声明\" class=\"headerlink\" title=\"类的声明\"></a>类的声明</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 类的声明</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Animal</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'name'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">// ES6中的class声明</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Animal2</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"实例化\"><a href=\"#实例化\" class=\"headerlink\" title=\"实例化\"></a>实例化</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">new</span> <span class=\"token class-name\">Animal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Animal2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><h3 id=\"1-构造函数实现继承\"><a href=\"#1-构造函数实现继承\" class=\"headerlink\" title=\"1. 构造函数实现继承\"></a>1. 构造函数实现继承</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Parent1</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'parent'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Child1</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token function\">Parent1</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//apply 改变运行上下文</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>type <span class=\"token operator\">=</span> <span class=\"token string\">'child1'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n缺点：无法继承原型中的属性方法<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"2-原型链继承\"><a href=\"#2-原型链继承\" class=\"headerlink\" title=\"2. 原型链继承\"></a>2. 原型链继承</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Parent2</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'parent2'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>play <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Child2</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'Child2'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token class-name\">Child2</span><span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Parent2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Child2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">var</span> s1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Child2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> s2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Child2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">.</span>play<span class=\"token punctuation\">,</span>s2<span class=\"token punctuation\">.</span>play<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ns1<span class=\"token punctuation\">.</span>play<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n缺点：共用一个原型<span class=\"token punctuation\">,</span>Child2的实例对象修改原型属性值，其他的实例对象的值会被修改<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"3-组合方式继承\"><a href=\"#3-组合方式继承\" class=\"headerlink\" title=\"3. 组合方式继承\"></a>3. 组合方式继承</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Parent3</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'parent3'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>play <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Child3</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token function\">Parent1</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'Child3'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token class-name\">Child3</span><span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Parent3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> s3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Child3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> s4 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Child3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ns3<span class=\"token punctuation\">.</span>play<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>s3<span class=\"token punctuation\">.</span>play<span class=\"token punctuation\">,</span>s4<span class=\"token punctuation\">.</span>play<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n缺点：父级的构造函数执行两次<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"4-组合继承的优化\"><a href=\"#4-组合继承的优化\" class=\"headerlink\" title=\"4. 组合继承的优化\"></a>4. 组合继承的优化</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Parent4</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'parent4'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>play <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Child4</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token function\">Parent1</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'Child4'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token class-name\">Child4</span><span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token class-name\">Parent4</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> s5 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Child4</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> s6 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Child4</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>s5<span class=\"token punctuation\">.</span>constructor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n缺点：console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>s5 <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Child4</span><span class=\"token punctuation\">,</span>s5 <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Parent4</span><span class=\"token punctuation\">)</span>都为<span class=\"token boolean\">true</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"5-组合继承优化2\"><a href=\"#5-组合继承优化2\" class=\"headerlink\" title=\"5.组合继承优化2\"></a>5.组合继承优化2</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Parent5</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'parent5'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>play <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Child5</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token function\">Parent1</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'Child5'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token class-name\">Child5</span><span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Parent5</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//__proto__</span>\n<span class=\"token class-name\">Child5</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">=</span> Child5<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> s7 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Child5</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>s7 <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Child5</span><span class=\"token punctuation\">,</span> s7 <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Parent5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>s7<span class=\"token punctuation\">.</span>constructor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"通信类\"><a href=\"#通信类\" class=\"headerlink\" title=\"通信类\"></a>通信类</h1><h2 id=\"什么是同源策略及限制\"><a href=\"#什么是同源策略及限制\" class=\"headerlink\" title=\"什么是同源策略及限制\"></a>什么是同源策略及限制</h2><p>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于格力潜在恶意文件的关键的安全机制。</p>\n<p>同源： 协议、域名、端口</p>\n<h2 id=\"前后端如何通信\"><a href=\"#前后端如何通信\" class=\"headerlink\" title=\"前后端如何通信\"></a>前后端如何通信</h2><ol>\n<li>Ajax 同源</li>\n<li>WebSocket </li>\n<li>CORS </li>\n</ol>\n<h2 id=\"如何创建Ajax\"><a href=\"#如何创建Ajax\" class=\"headerlink\" title=\"如何创建Ajax\"></a>如何创建Ajax</h2><ul>\n<li>XMLHttpRequest对象的工作流程</li>\n<li>兼容性处理</li>\n<li>事件的触发条件</li>\n<li>事件的触发顺序</li>\n</ul>\n<h2 id=\"跨域通信的几种方式\"><a href=\"#跨域通信的几种方式\" class=\"headerlink\" title=\"跨域通信的几种方式\"></a>跨域通信的几种方式</h2><ol>\n<li>JSONP</li>\n<li>Hash</li>\n<li>postMessage</li>\n<li>WebSocket</li>\n<li>CORS</li>\n</ol>\n<h1 id=\"安全类\"><a href=\"#安全类\" class=\"headerlink\" title=\"安全类\"></a>安全类</h1><h2 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h2><p>跨站请求伪造 未经用户许可，偷偷的使用用户名义，发送恶意请求的攻击。通常情况下借助用户cookie来骗取服务器信任。</p>\n<p>CSRF（通常）发生在第三方域名。 CSRF攻击者（通常）不能获取到Cookie等信息，只是使用。</p>\n<p>防御</p>\n<ul>\n<li>Token验证</li>\n<li>Referer验证</li>\n<li>隐藏令牌</li>\n</ul>\n<h2 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h2><p>跨站脚本攻击：XSS本质是Html注入，攻击者在网站上注入恶意的js代码，对客户端页面进行篡改，进而窃取隐私数据比如cookie、session，或者重定向到不好的网站等。</p>\n<h1 id=\"渲染机制\"><a href=\"#渲染机制\" class=\"headerlink\" title=\"渲染机制\"></a>渲染机制</h1><h2 id=\"什么是DOCTYPE及作用\"><a href=\"#什么是DOCTYPE及作用\" class=\"headerlink\" title=\"什么是DOCTYPE及作用\"></a>什么是DOCTYPE及作用</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token constant\">DOCTYPE</span> html<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这行代码是一个声明， 其作用是告诉浏览器按照哪一种HTML文档规范解析HTML文档。</p>\n<!DOCTYPEhtml><p>为HTML 5的声明。一般情况下我们新写的前端工程就用这个声明就可以，否则一些新的标准特性是不能用的，比如说canvas标签。不去声明doctype也是不可取的。不同浏览器对这种情况有不同的默认规范，并不一致，所以，一定要声明好doctype，要注意一定加上感叹号。</p>\n<p>严格模式和混杂模式</p>\n<h2 id=\"浏览器的渲染过程\"><a href=\"#浏览器的渲染过程\" class=\"headerlink\" title=\"浏览器的渲染过程\"></a>浏览器的渲染过程</h2><ol>\n<li><p>HTML 被 HTML 解析器解析成 DOM 树；</p>\n</li>\n<li><p>CSS  被 CSS 解析器解析成 CSSOM 树；</p>\n</li>\n<li><p>结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；</p>\n</li>\n<li><p>生成布局Layout(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；</p>\n</li>\n<li><p>将布局绘制(paint)在屏幕上，显示出整个页面。</p>\n</li>\n</ol>\n<p>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染。</p>\n<h2 id=\"重排-reflow-和重绘-repaint\"><a href=\"#重排-reflow-和重绘-repaint\" class=\"headerlink\" title=\"重排(reflow)和重绘(repaint)\"></a><a href=\"https://juejin.cn/post/6844904083212468238\">重排(reflow)和重绘(repaint)</a></h2><h3 id=\"重排\"><a href=\"#重排\" class=\"headerlink\" title=\"重排\"></a>重排</h3><p>当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。</p>\n<p>重排也叫回流，简单的说就是重新生成布局，重新排列元素</p>\n<h4 id=\"触发Reflow\"><a href=\"#触发Reflow\" class=\"headerlink\" title=\"触发Reflow\"></a>触发Reflow</h4><ul>\n<li><p>页面初始渲染，这是开销最大的一次重排</p>\n</li>\n<li><p>添加/删除可见的DOM元素</p>\n</li>\n<li><p>改变元素位置</p>\n</li>\n<li><p>改变元素尺寸，比如边距、填充、边框、宽度和高度等</p>\n</li>\n<li><p>改变元素内容，比如文字数量，图片大小等</p>\n</li>\n<li><p>改变元素字体大小</p>\n</li>\n<li><p>改变浏览器窗口尺寸，比如resize事件发生时</p>\n</li>\n<li><p>激活CSS伪类（例如：:hover）</p>\n</li>\n<li><p>设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow</p>\n</li>\n<li><p>查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 getComputedStyle方法，或者IE里的 currentStyle 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。</p>\n</li>\n</ul>\n<h3 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h3><p>当我们改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸和位置没有发生改变</p>\n<h4 id=\"触发Repaint\"><a href=\"#触发Repaint\" class=\"headerlink\" title=\"触发Repaint\"></a>触发Repaint</h4><p><code>reflow</code>回流必定引起<code>repaint</code>重绘，重绘可以单独触发。<br>背景色、颜色、字体改变（注意：字体大小发生变化时，会触发回流）</p>\n<h3 id=\"减少reflow、repaint触发次数\"><a href=\"#减少reflow、repaint触发次数\" class=\"headerlink\" title=\"减少reflow、repaint触发次数\"></a>减少reflow、repaint触发次数</h3><ul>\n<li><p>用<code>transform</code>做形变和位移可以减少<code>reflow</code></p>\n</li>\n<li><p>避免逐个修改节点样式，尽量一次性修改</p>\n</li>\n<li><p>使用<code>DocumentFragment</code>将需要多次修改的DOM元素缓存，最后一次性<code>append</code>到真实DOM中渲染</p>\n</li>\n<li><p>可以将需要多次修改的DOM元素设置<code>display:none</code>，操作完再显示。（因为隐藏元素不在<code>render</code>树内，因此修改隐藏元素不会触发回流重绘）</p>\n</li>\n<li><p>避免多次读取某些属性</p>\n</li>\n<li><p>通过绝对位移将复杂的节点元素脱离文档流，形成新的Render Layer，降低回流成本</p>\n</li>\n</ul>\n<h1 id=\"JS运行机制\"><a href=\"#JS运行机制\" class=\"headerlink\" title=\"JS运行机制\"></a>JS运行机制</h1><h3 id=\"Event-Loop\"><a href=\"#Event-Loop\" class=\"headerlink\" title=\"Event Loop\"></a><a href=\"https://zhuanlan.zhihu.com/p/33058983\">Event Loop</a></h3><p>javascript从诞生之日起就是一门单线程的非阻塞的脚本语言</p>\n<p>当javascript代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 但是我们这里说的执行栈和上面这个栈的意义却有些不同</p>\n<p>我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文</p>\n<p>一个方法执行会向执行栈中加入这个方法的执行环境，js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列，被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕</p>\n<p>异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）</p>\n<p>以下事件属于宏任务：</p>\n<ul>\n<li><p>setInterval()</p>\n</li>\n<li><p>setTimeout()</p>\n</li>\n</ul>\n<p>以下事件属于微任务</p>\n<ul>\n<li><p>new Promise()</p>\n</li>\n<li><p>new MutaionObserver()</p>\n</li>\n</ul>\n<p>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行</p>\n<h1 id=\"页面性能优化\"><a href=\"#页面性能优化\" class=\"headerlink\" title=\"页面性能优化\"></a>页面性能优化</h1><ol>\n<li>资源压缩合并，减少HTTP请求</li>\n<li>非核心代码的异步加载</li>\n<li>利用浏览器缓存</li>\n<li>使用CDN</li>\n<li>预解析DNS</li>\n</ol>\n<p>预解析的实现：</p>\n<ol>\n<li>用meta信息来告知浏览器, 当前页面要做DNS预解析:<meta http-equiv=\"x-dns-prefetch-control\" content=\"on\" /></li>\n<li>在页面header中使用link标签来强制对DNS预解析: <link rel=\"dns-prefetch\" href=\"http://bdimg.share.baidu.com\" /></li>\n</ol>\n<h2 id=\"异步加载\"><a href=\"#异步加载\" class=\"headerlink\" title=\"异步加载\"></a>异步加载</h2><h3 id=\"异步加载方式\"><a href=\"#异步加载方式\" class=\"headerlink\" title=\"异步加载方式\"></a>异步加载方式</h3><ol>\n<li>动态脚本加载</li>\n<li>defer</li>\n<li>async</li>\n</ol>\n<h3 id=\"异步加载的区别\"><a href=\"#异步加载的区别\" class=\"headerlink\" title=\"异步加载的区别\"></a>异步加载的区别</h3><ol>\n<li>defer是在HTML解析完之后会执行，如果是多个，按照加载的顺序依次执行</li>\n<li>async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关</li>\n</ol>\n<h2 id=\"浏览器的缓存\"><a href=\"#浏览器的缓存\" class=\"headerlink\" title=\"浏览器的缓存\"></a>浏览器的缓存</h2><h3 id=\"强制缓存\"><a href=\"#强制缓存\" class=\"headerlink\" title=\"强制缓存\"></a>强制缓存</h3><ul>\n<li><p>Expires和Cache-Control，其中Cache-Control优先级比Expires高。</p>\n</li>\n<li><p>到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义</p>\n</li>\n<li><p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p>\n</li>\n</ul>\n<h3 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h3><ul>\n<li><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</p>\n</li>\n<li><p>协商缓存生效，返回304</p>\n</li>\n<li><p>协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高</p>\n</li>\n</ul>\n<blockquote>\n<p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存</p>\n</blockquote>\n<h1 id=\"错误监控\"><a href=\"#错误监控\" class=\"headerlink\" title=\"错误监控\"></a>错误监控</h1><h2 id=\"即时运行错误的捕获方式\"><a href=\"#即时运行错误的捕获方式\" class=\"headerlink\" title=\"即时运行错误的捕获方式\"></a>即时运行错误的捕获方式</h2><ol>\n<li>try.catch</li>\n<li>Window.onerror</li>\n</ol>\n<h2 id=\"资源加载错误\"><a href=\"#资源加载错误\" class=\"headerlink\" title=\"资源加载错误\"></a>资源加载错误</h2><ol>\n<li>Object.onerror</li>\n<li>Performance.getEntries()</li>\n<li>Error事件捕获</li>\n</ol>\n<h2 id=\"延伸：跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理\"><a href=\"#延伸：跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理\" class=\"headerlink\" title=\"延伸：跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理\"></a>延伸：跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理</h2><p><img src=\"./WX20220119-163009@2x.png\"></p>\n<!-- <img src=\"/Users/weichengzong/My/文档目录/前端知识点/WX20220119-163009@2x.png\" style=\"zoom:50%;\" /> -->\n\n<ol>\n<li>在script标签增加crossorigin属性</li>\n<li>设置js资源响应头Access-Control-Allow-Origin:*</li>\n</ol>\n<h2 id=\"上报错误的基本原理\"><a href=\"#上报错误的基本原理\" class=\"headerlink\" title=\"上报错误的基本原理\"></a>上报错误的基本原理</h2><ol>\n<li>采用Ajax通信的方式上报</li>\n<li>利用Image对象上报</li>\n</ol>\n<p>本文链接： <a href=\"http://www.vizong.cn/6/\">http://www.vizong.cn/6/</a> </p>\n","categories":["前端","面试"],"tags":[]},{"title":"知识点汇总一","url":"http://www.vizong.cn/5/","content":"<h1 id=\"三栏布局\"><a href=\"#三栏布局\" class=\"headerlink\" title=\"三栏布局\"></a>三栏布局</h1><p>高度固定，左右宽度300px,中间自适应</p>\n<ol>\n<li>浮动</li>\n<li>绝对定位</li>\n<li>flex布局</li>\n<li>table布局</li>\n<li>grid布局</li>\n</ol>\n<h1 id=\"CSS盒模型\"><a href=\"#CSS盒模型\" class=\"headerlink\" title=\"CSS盒模型\"></a>CSS盒模型</h1><p>css盒子模型 又称框模型 (Box Model) ，包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素</p>\n<h2 id=\"标准模型-IE模型\"><a href=\"#标准模型-IE模型\" class=\"headerlink\" title=\"标准模型+IE模型\"></a>标准模型+IE模型</h2><img src=\"http://img.smyhvae.com/2015-10-03-css-27.jpg\" alt=\"标准模\" style=\"zoom:45%;\" />\n\n<img src=\"http://img.smyhvae.com/2015-10-03-css-30.jpg\" alt=\"IE模\" style=\"zoom:45%;\" />\n\n<h2 id=\"css如何设置两种模型\"><a href=\"#css如何设置两种模型\" class=\"headerlink\" title=\"css如何设置两种模型\"></a>css如何设置两种模型</h2><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\"><span class=\"token property\">box-sizing</span><span class=\"token punctuation\">:</span>content-box<span class=\"token punctuation\">;</span> // 标准盒模型\n<span class=\"token property\">box-sizing</span><span class=\"token punctuation\">:</span>border-box<span class=\"token punctuation\">;</span> // IE盒模型<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h2><p>BFC(Block formatting context)直译为”块级格式化上下文”</p>\n<h3 id=\"BFC的布局规则-基本原理\"><a href=\"#BFC的布局规则-基本原理\" class=\"headerlink\" title=\"BFC的布局规则/基本原理\"></a>BFC的布局规则/基本原理</h3><ul>\n<li><p>内部的Box会在垂直方向，一个接一个地放置。</p>\n</li>\n<li><p>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。</p>\n</li>\n<li><p>每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的*格式化，否则相反)。即使存在浮动也是如此。</p>\n</li>\n<li><p>BFC的区域不会与float box重叠。</p>\n</li>\n<li><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p>\n</li>\n<li><p>计算BFC的高度时，浮动元素也参与计算</p>\n</li>\n</ul>\n<h3 id=\"如何创建BFC\"><a href=\"#如何创建BFC\" class=\"headerlink\" title=\"如何创建BFC\"></a>如何创建BFC</h3><ol>\n<li><p>overflow不为visible;</p>\n</li>\n<li><p>float的值不为none；</p>\n</li>\n<li><p>position的值不为static或relative；</p>\n</li>\n<li><p>display属性为inline-blocks,table,table-cell,table-caption,flex,inline-flex;</p>\n</li>\n</ol>\n<h3 id=\"实际应用\"><a href=\"#实际应用\" class=\"headerlink\" title=\"实际应用\"></a>实际应用</h3><ul>\n<li><p>解决相邻元素margin重叠的问题</p>\n</li>\n<li><p>布局中的浮动</p>\n</li>\n</ul>\n<h1 id=\"DOM事件\"><a href=\"#DOM事件\" class=\"headerlink\" title=\"DOM事件\"></a>DOM事件</h1><p>基本概念：DOM事件的级别</p>\n<p>DOM事件模型：冒泡和捕获</p>\n<h2 id=\"DOM事件的级别\"><a href=\"#DOM事件的级别\" class=\"headerlink\" title=\"DOM事件的级别\"></a>DOM事件的级别</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">DOM0 \telement.onclick&#x3D;function()&#123;&#125;\n\nDOM2\telement.addEventListener(&#39;click&#39;,function()&#123;&#125;,false)\n\nDOM3\telement.addEventListener(&#39;keyup&#39;,function()&#123;&#125;,false)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"DOM事件模型\"><a href=\"#DOM事件模型\" class=\"headerlink\" title=\"DOM事件模型\"></a>DOM事件模型</h2><p>捕获和冒泡</p>\n<p>捕获是从上到下，冒泡是当前事件往上</p>\n<h2 id=\"DOM事件流\"><a href=\"#DOM事件流\" class=\"headerlink\" title=\"DOM事件流\"></a>DOM事件流</h2><p>就是浏览器在为这个当前页面与用户做交互的过程中。用户点击了鼠标左键，这个左键是怎么传递的，它又怎么响应的。</p>\n<p>第一阶段：捕获。事件通过捕获到达目标元素（目标元素既目标阶段）。</p>\n<p>第二阶段：目标阶段。 比如说用户当前点击了这个按钮，这个按钮就是目标阶段</p>\n<p>第三阶段：冒泡 。 目标阶段通过冒泡上传到window对象</p>\n<h2 id=\"DOM事件捕获的具体流程\"><a href=\"#DOM事件捕获的具体流程\" class=\"headerlink\" title=\"DOM事件捕获的具体流程\"></a>DOM事件捕获的具体流程</h2><p>捕获是从上到下的这个过程，第一个接收事件的对象是window—&gt;document—&gt;html—&gt;body—&gt;….目标元素</p>\n<p> 比如我想取到body标签。可以使用window.docment.body来取到</p>\n<p> 但是html不能这样获取到，它是专门一个表示节点对象的document.documentElement </p>\n<h2 id=\"Event对象的常见应用\"><a href=\"#Event对象的常见应用\" class=\"headerlink\" title=\"Event对象的常见应用\"></a>Event对象的常见应用</h2><p>Event对象是事件响应中一个很重要的对象。因为我们经常会去获取用户交互的一个参数</p>\n<p>以下5个是常见却很容易弄混的。</p>\n<ol>\n<li><p>event.preventDefault();   阻止默认事件。</p>\n<p>比如说，一个a标签，a标签绑定了一个事件。那么在响应函数中，如果设置了event.preventDefault() . 就阻止了a标签的一个默认的跳转行为。</p>\n</li>\n<li><p>event.stopPropagation();  阻止冒泡的一个行为。</p>\n<p> 比如说，我父元素绑定一个事件，我子元素也绑定一个事件。这时我想子元素执行子元素的事件，父元素执行父元素的事件。</p>\n<p>如果你阻止冒泡，当单机子元素的时候，按照冒泡的原理，父元素也会被响应。这个时候就应该添加一个阻止冒泡。</p>\n</li>\n<li><p>event.stopImmediatePropagation() ;</p>\n<p> 比如说，一个按钮绑定了两个click事件。click1 和click2. 当我想通过优先的方式，当我想执行click1的时候不要执行click2了</p>\n<p>那么怎么办呢？？这时候在click1 事件中加入这么一句，它就能成功的阻止click2 事件的执行。</p>\n</li>\n<li><p>event.currentTarget</p>\n</li>\n<li><p>event.target </p>\n</li>\n</ol>\n<p>eg：事件委托。</p>\n<p>比如说 给你一个for循环，给一个dom注册了事件，要怎么优化。</p>\n<p>一个父元素有10个子元素，你又不想给10个子元素都绑定一个click元素。那么只要在父级元素上绑定一个事件就可以了。</p>\n<p>这个时候就可以使用事件委托。将子元素的事件转移到父元素身上。然后在绑定事件。然后再响应的时候，区分是哪个元素被点击。那么是怎么区分是哪个子元素被点击的呢？</p>\n<p>这个时候就是target上场的时候。</p>\n<h2 id=\"自定义事件-模拟事件\"><a href=\"#自定义事件-模拟事件\" class=\"headerlink\" title=\"自定义事件/模拟事件\"></a>自定义事件/模拟事件</h2><p>new Event（） 和 CustomEvent() </p>\n<p>两个的区别是 ：new Event（） 只能指定事件名，而CustomEvent 还能在后面加个参数。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> eat <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Event</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"eat\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nev<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"eat\"</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'eat'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n \nev<span class=\"token punctuation\">.</span><span class=\"token function\">dispatchEvent</span><span class=\"token punctuation\">(</span>eat<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ol>\n<li><p>new Event(“eat”)  ： 新建自定义事件并命名</p>\n</li>\n<li><p> 通过DOM2 这种事件的注册方式绑定事件名称：</p>\n</li>\n</ol>\n<p>​      ev.addEventListener(“eat”,function(){<br>            console.log(‘eat’);<br>​      })</p>\n<ol start=\"3\">\n<li>使用 ev.dispatchEvent(eat);  这个事件来触发eve这个对象。</li>\n</ol>\n<p>这样就达到了 自定义事件和响应自定义事件。</p>\n<h1 id=\"HTTP协议类\"><a href=\"#HTTP协议类\" class=\"headerlink\" title=\"HTTP协议类\"></a>HTTP协议类</h1><h2 id=\"HTTP协议的主要特点\"><a href=\"#HTTP协议的主要特点\" class=\"headerlink\" title=\"HTTP协议的主要特点\"></a>HTTP协议的主要特点</h2><ul>\n<li>简单快速</li>\n<li>灵活</li>\n<li>无连接</li>\n<li>无状态</li>\n</ul>\n<h2 id=\"HTTP报文的组成部分\"><a href=\"#HTTP报文的组成部分\" class=\"headerlink\" title=\"HTTP报文的组成部分\"></a>HTTP报文的组成部分</h2><p>请求报文</p>\n<ul>\n<li>请求行</li>\n<li>请求头</li>\n<li>空行</li>\n<li>请求体</li>\n</ul>\n<p>相应报文</p>\n<ul>\n<li>状态行</li>\n<li>相应头</li>\n<li>空行</li>\n<li>响应体</li>\n</ul>\n<h2 id=\"HTTP方法\"><a href=\"#HTTP方法\" class=\"headerlink\" title=\"HTTP方法\"></a>HTTP方法</h2><ul>\n<li>GET    获取资源</li>\n<li>POST   传输资源</li>\n<li>PUT    更新资源</li>\n<li>DELETE   删除资源</li>\n<li>HEAD    获得报文首部</li>\n</ul>\n<h2 id=\"HTTP状态吗\"><a href=\"#HTTP状态吗\" class=\"headerlink\" title=\"HTTP状态吗\"></a>HTTP状态吗</h2><ul>\n<li>1xx 提供信息,表示已经接受，正在处理</li>\n<li>100 continue主要用于提供信息</li>\n<li>101 切换协议：如果服务器切换了协议会向客户端返回101</li>\n<li>2xx 成功</li>\n<li>200:ok</li>\n<li>201：已创建</li>\n<li>202：已接收</li>\n<li>203：非权威内容</li>\n<li>204：请求成功，但是无资源返回</li>\n<li>205：重置内容</li>\n<li>206：客户端进行了范围请求，服务器成功执行力这部分的请求，返回头部有Content-range指定了范围的实体内容</li>\n<li>3xx重定向</li>\n<li>300:用户请求了多个选项的资源</li>\n<li>301：永久转移，资源已经被分配了新的URL，应该按照location部分的url重新保存</li>\n<li>302：临时重定向</li>\n<li>303：该资源存在着另一个URL，可以使用GET方法获取</li>\n<li>304：没有修改（协商缓存命中时返回这个状态码）</li>\n<li>305：使用代理</li>\n<li>307：临时重定向</li>\n<li>308：永久重定向</li>\n<li>4xx客户端错误</li>\n<li>400:报文存在语法错误</li>\n<li>401：需要认证信息</li>\n<li>403：被服务器拒绝</li>\n<li>404：服务器上没有该资源</li>\n<li>405：服务器禁止使用该方法</li>\n<li>5xx服务端错误 </li>\n</ul>\n<h2 id=\"持久连接\"><a href=\"#持久连接\" class=\"headerlink\" title=\"持久连接\"></a>持久连接</h2><p>HTTP协议采用‘请求-应答’模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建一个连接，完成柱子后立即断开连接（HTTP协议为无连接的协议）</p>\n<p>当使用 Keep-Alive 模式 （又称持久连接、连接重用）时，Keep-Alive功能是客户端到服务器短的连接持续有效，当出现对服务器的后续请求时，Keep-Alive功能避免了建立或者重新建立连接</p>\n<h2 id=\"管线化\"><a href=\"#管线化\" class=\"headerlink\" title=\"管线化\"></a>管线化</h2><p>在使用持久连接的情况下，某个连接上的消息传递类似于</p>\n<p>请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 -&gt; 响应3<br>管线化，某个连接上的消息变成了类似下面这样 （相当于将请求打包一次传输过去，服务端也打包响应回来）</p>\n<p>请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3</p>\n<ul>\n<li>管线化机智通过持久连接完成，仅HTTP/1.1支持此技术</li>\n<li>只有GET和HEAD请求可以进行管线化，而POST则有所限制</li>\n<li>初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持HTTP/1.1版本的协议；</li>\n<li>管线化不会用箱响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变</li>\n<li>HTTP1.1要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可</li>\n<li>现在很多服务器端和代理程序对管线化的支持并不好，现代浏览器Chrome和Firefox默认并未开启管线化支持</li>\n</ul>\n<p>本文链接： <a href=\"http://www.vizong.cn/5/\">http://www.vizong.cn/5/</a> </p>\n","categories":["前端","面试"],"tags":[]},{"title":"复习汇总","url":"http://www.vizong.cn/4/","content":"<h2 id=\"XSS和CSRF\"><a href=\"#XSS和CSRF\" class=\"headerlink\" title=\"XSS和CSRF\"></a>XSS和CSRF</h2><p>CSRF:跨站请求伪造 未经用户许可，偷偷的使用用户名义，发送恶意请求的攻击。通常情况下借助用户cookie来骗取服务器信任。<br>CSRF（通常）发生在第三方域名。 CSRF攻击者（通常）不能获取到Cookie等信息，只是使用。</p>\n<p>XSS跨站脚本攻击：XSS本质是Html注入，攻击者在网站上注入恶意的js代码，对客户端页面进行篡改，进而窃取隐私数据比如cookie、session，或者重定向到不好的网站等。</p>\n<ul>\n<li>在HTTP头部配上，set-cookie：httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie</li>\n<li>secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie<h2 id=\"HTTP2-0相比1-1\"><a href=\"#HTTP2-0相比1-1\" class=\"headerlink\" title=\"HTTP2.0相比1.1\"></a>HTTP2.0相比1.1</h2></li>\n</ul>\n<ol>\n<li>头部压缩。如果同时发出多个请求，头部有相似的字段，协议会消除重复的部分。（HPACK算法：在客户端和服务器维护一张头信息表，所有字段都会存入，生成一个索引号，之后就只发索引号）</li>\n<li>二进制形式。HTTP1.1还是纯文本形式，2版本全面采用二进制形式（头信息帧+数据帧）</li>\n<li>数据流。2版本不是按顺序发送的，所以需要对数据包做标记，客户端还可以指定优先级。</li>\n<li>多路复用。在一个连接里并发多个请求。</li>\n<li>服务器推送，服务器可以主动向客户端发信息。</li>\n</ol>\n<h2 id=\"从输入URL到页面加载完成的过程中发生了什么\"><a href=\"#从输入URL到页面加载完成的过程中发生了什么\" class=\"headerlink\" title=\"从输入URL到页面加载完成的过程中发生了什么\"></a>从输入URL到页面加载完成的过程中发生了什么</h2><ol>\n<li><p>键盘或触屏输入URL并回车确认</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">一个合法的URL包括协议，域名，端口号，请求资源路径，传参信息，hash值。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>URL解析/DNS解析查找域名IP地址</p>\n</li>\n<li><p>建立TCP连接 <a href=\"https://www.cnblogs.com/bj-mr-li/p/11106390.html\">三次握手</a></p>\n</li>\n<li><p>网络连接发起HTTP请求</p>\n</li>\n<li><p><a href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5\">浏览器缓存策略</a></p>\n</li>\n<li><p>相应http请求</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">响应报文：响应行（协议、版本、状态码） 响应头 响应体\n\n状态码（响应报文头部）\n* 1xx 提供信息,表示已经接受，正在处理\n* 100 continue主要用于提供信息\n* 101 切换协议：如果服务器切换了协议会向客户端返回101\n* 2xx 成功\n* 200:ok\n* 201：已创建\n* 202：已接收\n* 203：非权威内容\n* 204：请求成功，但是无资源返回\n* 205：重置内容\n* 206：客户端进行了范围请求，服务器成功执行力这部分的请求，返回头部有Content-range指定了范围的实体内容\n* 3xx重定向\n* 300:用户请求了多个选项的资源\n* 301：永久转移，资源已经被分配了新的URL，应该按照location部分的url重新保存\n* 302：临时重定向\n* 303：该资源存在着另一个URL，可以使用GET方法获取\n* 304：没有修改（协商缓存命中时返回这个状态码）\n* 305：使用代理\n* 307：临时重定向\n* 308：永久重定向\n* 4xx客户端错误\n* 400:报文存在语法错误\n* 401：需要认证信息\n* 403：被服务器拒绝\n* 404：服务器上没有该资源\n* 405：服务器禁止使用该方法\n* 5xx服务端错误 <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>客户端浏览器接收数据解析html,并请求代码中的资源</p>\n</li>\n<li><p>浏览器加载/渲染页面<br><a href=\"#%E9%A1%B5%E9%9D%A2%E7%94%9F%E6%88%90%E6%B8%B2%E6%9F%93%E7%9A%84%E8%BF%87%E7%A8%8B\">页面生成渲染的过程</a></p>\n</li>\n<li><p>关闭连接（四次挥手）</p>\n</li>\n</ol>\n<h2 id=\"前端路由的两种模式：hash模式和-history模式\"><a href=\"#前端路由的两种模式：hash模式和-history模式\" class=\"headerlink\" title=\"前端路由的两种模式：hash模式和 history模式\"></a><a href=\"https://blog.csdn.net/Charissa2017/article/details/104779412\">前端路由的两种模式：hash模式和 history模式</a></h2><p>单页面应用利用了JavaScript动态变换网页内容，避免了页面重载；路由则提供了浏览器地址变化，网页内容也跟随变化，两者结合起来则为我们提供了体验良好的单页面web应用。</p>\n<ul>\n<li>hash模式：监听浏览器地址hash值变化，执行相应的js切换网页；</li>\n<li>history模式：利用history API实现url地址改变，网页内容改变；</li>\n</ul>\n<h2 id=\"页面生成渲染的过程\"><a href=\"#页面生成渲染的过程\" class=\"headerlink\" title=\"页面生成渲染的过程\"></a>页面生成渲染的过程</h2><ol>\n<li>HTML 被 HTML 解析器解析成 DOM 树；</li>\n<li>CSS  被 CSS 解析器解析成 CSSOM 树；</li>\n<li>结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；</li>\n<li>生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；</li>\n<li>将布局绘制(paint)在屏幕上，显示出整个页面。<br>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染。</li>\n</ol>\n<h2 id=\"浏览器缓存策略\"><a href=\"#浏览器缓存策略\" class=\"headerlink\" title=\"浏览器缓存策略\"></a><a href=\"https://juejin.cn/post/6844903593275817998\">浏览器缓存策略</a></h2><p>根据是否需要向服务器重新发起HTTP请求将缓存分为两个部分</p>\n<ul>\n<li><p>强制缓存</p>\n</li>\n<li><p>协商缓存</p>\n<h3 id=\"强制缓存\"><a href=\"#强制缓存\" class=\"headerlink\" title=\"强制缓存\"></a>强制缓存</h3><ul>\n<li><p>Expires和Cache-Control，其中Cache-Control优先级比Expires高。</p>\n</li>\n<li><p>到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义</p>\n</li>\n<li><p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p>\n</li>\n</ul>\n<h3 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h3><ul>\n<li>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</li>\n<li>协商缓存生效，返回304</li>\n<li>协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存</p>\n</blockquote>\n<h2 id=\"移动端适配，响应式布局的解决方案\"><a href=\"#移动端适配，响应式布局的解决方案\" class=\"headerlink\" title=\"移动端适配，响应式布局的解决方案\"></a><a href=\"https://github.com/forthealllight/blog/issues/13\">移动端适配，响应式布局的解决方案</a></h2><ol>\n<li>px和视口</li>\n<li>媒体查询</li>\n<li>百分比</li>\n<li>自适应场景下的rem解决方案</li>\n<li>通过vw/vh来实现自适应<h2 id=\"JS数据类型\"><a href=\"#JS数据类型\" class=\"headerlink\" title=\"JS数据类型\"></a><a href=\"https://blog.csdn.net/u013592575/article/details/95087953\">JS数据类型</a></h2>在ES5的时候，我们认知的数据类型确实是 6种：Number、String、Boolean、undefined、object、Null。<br>ES6 中新增了一种 Symbol 。这种类型的对象永不相等，即始创建的时候传入相同的值，可以解决属性名冲突的问题，做为标记。<br>谷歌67版本中还出现了一种 bigInt。是指安全存储、操作大整数。（但是很多人不把这个做为一个类型。</li>\n</ol>\n<ul>\n<li>基本类型（单类型）：除Object。 String、Number、boolean、null、undefined。</li>\n<li>引用类型：object,里面包含function、Array、Date</li>\n</ul>\n<h2 id=\"原型及原型链\"><a href=\"#原型及原型链\" class=\"headerlink\" title=\"原型及原型链\"></a><a href=\"https://github.com/mqyqingfeng/Blog/issues/2\">原型及原型链</a></h2><p>那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p>\n<p><img src=\"https://camo.githubusercontent.com/9a69b0f03116884e80cf566f8542cf014a4dd043fce6ce030d615040461f4e5a/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065352e706e67\" alt=\"关系图\"><br>图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线</p>\n<h2 id=\"作用域和作用域链\"><a href=\"#作用域和作用域链\" class=\"headerlink\" title=\"作用域和作用域链\"></a>作用域和作用域链</h2><blockquote>\n<p>作用域链:在《JavaScript深入之变量对象》中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p>\n</blockquote>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/6\">JavaScript深入之作用域链</a><br><a href=\"https://blog.csdn.net/yueguanghaidao/article/details/9568071\">Js作用域与作用域链详解</a></p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a><a href=\"https://github.com/mqyqingfeng/Blog/issues/9\">闭包</a></h2><p>MDN对闭包的定义：</p>\n<blockquote>\n<p>闭包是指那些能够访问自由变量的函数。<br>那什么是自由变量呢？<br>自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。<br>由此，我们可以看出闭包共有两部分组成：<br>闭包 = 函数 + 函数能够访问的自由变量</p>\n</blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。</p>\n<h2 id=\"JS中继承实现的几种方式\"><a href=\"#JS中继承实现的几种方式\" class=\"headerlink\" title=\"JS中继承实现的几种方式\"></a>JS中继承实现的几种方式</h2><ol>\n<li>原型链继承，将父类的实例作为子类的原型，他的特点是实例是子类的实例也是父类的实例，父类新增的原型方法/属性，子类都能够访问，并且原型链继承简单易于实现，缺点是来自原型对象的所有属性被所有实例共享，无法实现多继承，无法向父类构造函数传参。</li>\n<li>构造继承，使用父类的构造函数来增强子类实例，即复制父类的实例属性给子类，<br>构造继承可以向父类传递参数，可以实现多继承，通过call多个父类对象。但是构造继承只能继承父类的实例属性和方法，不能继承原型属性和方法，无法实现函数服用，每个子类都有父类实例函数的副本，影响性能</li>\n<li>实例继承，为父类实例添加新特性，作为子类实例返回，实例继承的特点是不限制调用方法，不管是new 子类（）还是子类（）返回的对象具有相同的效果，缺点是实例是父类的实例，不是子类的实例，不支持多继承</li>\n<li>拷贝继承：特点：支持多继承，缺点：效率较低，内存占用高（因为要拷贝父类的属性）无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</li>\n<li>组合继承：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</li>\n<li>寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</li>\n</ol>\n<h2 id=\"typeof-amp-amp-instanceof\"><a href=\"#typeof-amp-amp-instanceof\" class=\"headerlink\" title=\"typeof &amp;&amp; instanceof\"></a><a href=\"https://juejin.cn/post/6844903613584654344\">typeof &amp;&amp; instanceof</a></h2><p>简单来说，我们使用 typeof 来判断基本数据类型是 ok 的，不过需要注意当用 typeof 来判断 null 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 instanceof，但是 instanceof 也可能判断不准确，比如一个数组，他可以被 instanceof 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 Object.prototype.toString.call 方法。</p>\n<h2 id=\"Event-Loop\"><a href=\"#Event-Loop\" class=\"headerlink\" title=\"Event Loop\"></a><a href=\"https://zhuanlan.zhihu.com/p/33058983\">Event Loop</a></h2><p>javascript从诞生之日起就是一门单线程的非阻塞的脚本语言</p>\n<p>当javascript代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 但是我们这里说的执行栈和上面这个栈的意义却有些不同</p>\n<p>我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文</p>\n<p>一个方法执行会向执行栈中加入这个方法的执行环境，js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列，被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕</p>\n<p>异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）<br>以下事件属于宏任务：</p>\n<ul>\n<li>setInterval()</li>\n<li>setTimeout()</li>\n</ul>\n<p>以下事件属于微任务</p>\n<ul>\n<li>new Promise()</li>\n<li>new MutaionObserver()</li>\n</ul>\n<p>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行</p>\n<h2 id=\"Promise原理\"><a href=\"#Promise原理\" class=\"headerlink\" title=\"Promise原理\"></a>Promise原理</h2><p>Promise 必须为以下三种状态之一：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。一旦Promise 被 resolve 或 reject，不能再迁移至其他任何状态（即状态 immutable）</p>\n<h2 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a><a href=\"https://blog.csdn.net/sinat_36422236/article/details/88763187\">BFC</a></h2><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干</p>\n<p>BFC的布局规则</p>\n<ul>\n<li>内部的Box会在垂直方向，一个接一个地放置。</li>\n<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。</li>\n<li>每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的*格式化，否则相反)。即使存在浮动也是如此。</li>\n<li>BFC的区域不会与float box重叠。</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>\n<li>计算BFC的高度时，浮动元素也参与计算</li>\n</ul>\n<p>如何创建BFC</p>\n<ol>\n<li>overflow不为visible;</li>\n<li>float的值不为none；</li>\n<li>position的值不为static或relative；</li>\n<li>display属性为inline-blocks,table,table-cell,table-caption,flex,inline-flex;</li>\n</ol>\n<h2 id=\"伪元素和伪类\"><a href=\"#伪元素和伪类\" class=\"headerlink\" title=\"伪元素和伪类\"></a>伪元素和伪类</h2><p>伪类与伪元素之差别：<br>书写上：伪元素最大程度可使用双冒号，伪类使用但冒号；<br>运用上：每个选择器最多只能使用一个伪元素，每个选择器可以使用多个伪类；</p>\n<h2 id=\"CSS3新特性\"><a href=\"#CSS3新特性\" class=\"headerlink\" title=\"CSS3新特性\"></a><a href=\"https://segmentfault.com/a/1190000010780991\">CSS3新特性</a></h2><ol>\n<li>过渡</li>\n<li>动画</li>\n<li>形状转化</li>\n<li>选择器</li>\n<li>阴影</li>\n<li>边框图片</li>\n<li>背景的三个属性</li>\n<li>反射</li>\n<li>文字</li>\n<li>颜色</li>\n<li>渐变</li>\n<li>滤镜Filter</li>\n<li>弹性布局</li>\n<li>栅格布局</li>\n<li>多列布局</li>\n<li>盒模型定义</li>\n<li>媒体查询</li>\n<li>混合模式</li>\n</ol>\n<h2 id=\"重排-reflow-和重绘-repaint\"><a href=\"#重排-reflow-和重绘-repaint\" class=\"headerlink\" title=\"重排(reflow)和重绘(repaint)\"></a><a href=\"https://juejin.cn/post/6844904083212468238\">重排(reflow)和重绘(repaint)</a></h2><h3 id=\"重排\"><a href=\"#重排\" class=\"headerlink\" title=\"重排\"></a>重排</h3><p>当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。</p>\n<p>重排也叫回流，简单的说就是重新生成布局，重新排列元素</p>\n<h4 id=\"下面情况会发生重排：\"><a href=\"#下面情况会发生重排：\" class=\"headerlink\" title=\"下面情况会发生重排：\"></a>下面情况会发生重排：</h4><ul>\n<li>页面初始渲染，这是开销最大的一次重排</li>\n<li>添加/删除可见的DOM元素</li>\n<li>改变元素位置</li>\n<li>改变元素尺寸，比如边距、填充、边框、宽度和高度等</li>\n<li>改变元素内容，比如文字数量，图片大小等</li>\n<li>改变元素字体大小</li>\n<li>改变浏览器窗口尺寸，比如resize事件发生时</li>\n<li>激活CSS伪类（例如：:hover）</li>\n<li>设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow</li>\n<li>查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 getComputedStyle方法，或者IE里的 currentStyle 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。<h3 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h3>当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。</li>\n</ul>\n<h2 id=\"首屏白屏时间的优化\"><a href=\"#首屏白屏时间的优化\" class=\"headerlink\" title=\"首屏白屏时间的优化\"></a>首屏白屏时间的优化</h2><h3 id=\"白屏过程\"><a href=\"#白屏过程\" class=\"headerlink\" title=\"白屏过程\"></a>白屏过程</h3><ol>\n<li>DNS Lookup 即浏览器从DNS服务器中进行域名查询。</li>\n<li>建立TCP请求连接</li>\n<li>服务端请求处理响应</li>\n<li>客户端下载、解析、渲染显示页面</li>\n</ol>\n<blockquote>\n<p>参考：<a href=\"https://cloud.tencent.com/developer/article/1508941\">https://cloud.tencent.com/developer/article/1508941</a></p>\n</blockquote>\n<h2 id=\"前端优化\"><a href=\"#前端优化\" class=\"headerlink\" title=\"前端优化\"></a>前端优化</h2><ul>\n<li>降低请求量：合并资源，减少HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。</li>\n<li>加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。</li>\n<li>缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存localStorage。</li>\n<li>渲染：JS/CSS优化，加载顺序，服务端渲染，pipeline。</li>\n<li><a href=\"#%E9%A6%96%E5%B1%8F%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4%E7%9A%84%E4%BC%98%E5%8C%96\">首屏白屏时间的优化</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_43883485/article/details/103504171\">CSS性能优化</a><h2 id=\"webpack详解\"><a href=\"#webpack详解\" class=\"headerlink\" title=\"webpack详解\"></a>webpack详解</h2></li>\n</ul>\n<blockquote>\n<p>参考：<a href=\"https://bobi.ink/2019/10/01/babel/\">https://bobi.ink/2019/10/01/babel/</a></p>\n</blockquote>\n<blockquote>\n<p>参考：<a href=\"https://juejin.cn/post/6844903789804126222\">https://juejin.cn/post/6844903789804126222</a></p>\n</blockquote>\n<blockquote>\n<p>参考：<a href=\"https://github.com/youngwind/blog/issues/101\">https://github.com/youngwind/blog/issues/101</a></p>\n</blockquote>\n<h2 id=\"Babel详解\"><a href=\"#Babel详解\" class=\"headerlink\" title=\"Babel详解\"></a>Babel详解</h2><blockquote>\n<p>参考：<a href=\"https://bobi.ink/2019/10/01/babel/\">https://bobi.ink/2019/10/01/babel/</a></p>\n</blockquote>\n<h2 id=\"react的基本原理\"><a href=\"#react的基本原理\" class=\"headerlink\" title=\"react的基本原理\"></a>react的基本原理</h2><h2 id=\"react如何做性能优化\"><a href=\"#react如何做性能优化\" class=\"headerlink\" title=\"react如何做性能优化\"></a>react如何做性能优化</h2><ol>\n<li>避免内存泄露 setTimout()、addEventListener()及时销毁</li>\n<li>懒加载、异步组件</li>\n</ol>\n<h2 id=\"react-最新版本解决了什么问题-加了哪些东西\"><a href=\"#react-最新版本解决了什么问题-加了哪些东西\" class=\"headerlink\" title=\"react 最新版本解决了什么问题 加了哪些东西\"></a><a href=\"https://github.com/lgwebdream/FE-Interview/issues/13\">react 最新版本解决了什么问题 加了哪些东西</a></h2><h2 id=\"redux的重点概念\"><a href=\"#redux的重点概念\" class=\"headerlink\" title=\"redux的重点概念\"></a>redux的重点概念</h2><h2 id=\"react生命周期-15、16进行对比-16为什么废弃\"><a href=\"#react生命周期-15、16进行对比-16为什么废弃\" class=\"headerlink\" title=\"react生命周期 15、16进行对比 16为什么废弃\"></a>react生命周期 15、16进行对比 16为什么废弃</h2><h2 id=\"hooks如何处理生命周期\"><a href=\"#hooks如何处理生命周期\" class=\"headerlink\" title=\"hooks如何处理生命周期\"></a>hooks如何处理生命周期</h2><h2 id=\"interface-和-type-的区别\"><a href=\"#interface-和-type-的区别\" class=\"headerlink\" title=\"interface 和 type 的区别\"></a>interface 和 type 的区别</h2><h2 id=\"class-组件与函数式组件的区别\"><a href=\"#class-组件与函数式组件的区别\" class=\"headerlink\" title=\"class 组件与函数式组件的区别\"></a>class 组件与函数式组件的区别</h2><p>本文链接： <a href=\"http://www.vizong.cn/4/\">http://www.vizong.cn/4/</a> </p>\n","categories":["面试"],"tags":["面试"]},{"title":"Nginx同一个端口部署两个React项目","url":"http://www.vizong.cn/3/","content":"<h1 id=\"懒\"><a href=\"#懒\" class=\"headerlink\" title=\"懒\"></a>懒</h1><p>本文链接： <a href=\"http://www.vizong.cn/3/\">http://www.vizong.cn/3/</a> </p>\n","categories":["React"],"tags":[]},{"title":"Markdown语法","url":"http://www.vizong.cn/2/","content":"<h1 id=\"一、标题\"><a href=\"#一、标题\" class=\"headerlink\" title=\"一、标题\"></a>一、标题</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n######六级标题<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><p>######六级标题</p>\n<h1 id=\"二、字体\"><a href=\"#二、字体\" class=\"headerlink\" title=\"二、字体\"></a>二、字体</h1><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">**加粗文字**\n*倾斜文字*\n***斜体加粗文字***\n~~加删除线文字~~\n&#96;红色&#96;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>加粗文字</strong><br><em>倾斜文字</em><br><em><strong>斜体加粗文字</strong></em><br><del>加删除线文字</del> </p>\n<p><code>红色</code></p>\n<h1 id=\"三、引用\"><a href=\"#三、引用\" class=\"headerlink\" title=\"三、引用\"></a>三、引用</h1><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&gt;引用内容1\n&gt;&gt;引用内容2\n&gt;&gt;&gt;引用内容3<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>引用内容1</p>\n<blockquote>\n<p>引用内容2</p>\n<blockquote>\n<p>引用内容3</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1 id=\"四、列表\"><a href=\"#四、列表\" class=\"headerlink\" title=\"四、列表\"></a>四、列表</h1><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">无序列表 -+* 都可以\n- 列表内容-\n+ 列表内容+\n* 列表内容*\n有序列表 数字加点\n1. 列表内容\n2. 列表内容\n3. 列表内容<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>列表内容-</li>\n</ul>\n<ul>\n<li>列表内容+</li>\n</ul>\n<ul>\n<li>列表内容*</li>\n</ul>\n<ol>\n<li><p>列表内容</p>\n</li>\n<li><p>列表内容</p>\n</li>\n<li><p>列表内容</p>\n</li>\n</ol>\n<h1 id=\"五、分割线\"><a href=\"#五、分割线\" class=\"headerlink\" title=\"五、分割线\"></a>五、分割线</h1><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">三个及以上都可以\n---\n----\n***\n*****<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<hr>\n<hr>\n<hr>\n<h1 id=\"六、图片和链接\"><a href=\"#六、图片和链接\" class=\"headerlink\" title=\"六、图片和链接\"></a>六、图片和链接</h1><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">图片\n \t![](链接地址)\n链接\n\t[文字内容](链接地址)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"七、表格\"><a href=\"#七、表格\" class=\"headerlink\" title=\"七、表格\"></a>七、表格</h1><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">| 默认格式  | 左对齐 | 居中 | 右对齐 |\n| --- | :--- | :---: | ---: |\n| 默认格式表格内容  | 左对齐表格内容 | 居中表格内容 | 右对齐表格内容 |\n| 默认格式表格内容  | 左对齐表格内容 | 居中表格内容 | 右对齐表格内容 |<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<table>\n<thead>\n<tr>\n<th>默认格式</th>\n<th align=\"left\">左对齐</th>\n<th align=\"center\">居中</th>\n<th align=\"right\">右对齐</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>默认格式表格内容</td>\n<td align=\"left\">左对齐表格内容</td>\n<td align=\"center\">居中表格内容</td>\n<td align=\"right\">右对齐表格内容</td>\n</tr>\n<tr>\n<td>默认格式表格内容</td>\n<td align=\"left\">左对齐表格内容</td>\n<td align=\"center\">居中表格内容</td>\n<td align=\"right\">右对齐表格内容</td>\n</tr>\n</tbody></table>\n<p>本文链接： <a href=\"http://www.vizong.cn/2/\">http://www.vizong.cn/2/</a> </p>\n","categories":["Markdown"],"tags":[]},{"title":"Hello word","url":"http://www.vizong.cn/1/","content":"<h1 id=\"Hello-word\"><a href=\"#Hello-word\" class=\"headerlink\" title=\"Hello word\"></a>Hello word</h1><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello World\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>本文链接： <a href=\"http://www.vizong.cn/1/\">http://www.vizong.cn/1/</a> </p>\n","categories":["React"],"tags":["React"]},{"title":"404","url":"http://www.vizong.cn/404/index.html","content":"","categories":[],"tags":[]},{"title":"about","url":"http://www.vizong.cn/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://www.vizong.cn/category/index.html","content":"","categories":[],"tags":[]},{"title":"contact","url":"http://www.vizong.cn/contact/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://www.vizong.cn/link/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://www.vizong.cn/project/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://www.vizong.cn/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://www.vizong.cn/tag/index.html","content":"","categories":[],"tags":[]}]